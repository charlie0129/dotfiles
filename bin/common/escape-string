#!/usr/bin/env python3

# This script makes all escape characters visible from the input string.
# Well, just look at a example, then you will see what it does:

# == Input Begins ==
# Line 1
# Line 2
#     <- 4 spaces
# 	<- 1 tab
# \"'
# == Input Ends ==

# == Output Begins ==
# "Line 1\nLine 2\n    <- 4 spaces\n\t<- 1 tab\n\\\"'"
# == Output Ends ==

# == Output Begins == (multiline enabled)
# "Line 1\n" +
# "Line 2\n" +
# "    <- 4 spaces\n" +
# "\t<- 1 tab\n" +
# "\\\"'"
# == Output Ends == (multiline enabled)

# This script reads from stdin.
# So, use it like this: cat your-file | escape-string --multiline

import argparse
from sys import stdin, stdout

def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

parser = argparse.ArgumentParser()
parser.add_argument('--multiline', dest="multiline", nargs='?', type=str2bool, const=True, default=False, help="break escaped string into multiple lines")
args = parser.parse_args()

input = stdin.read()

output = input.replace('\a', '\\a') \
    .replace('\b', '\\b') \
    .replace('\\', '\\\\') \
    .replace('\t', '\\t') \
    .replace('\n', '\\n') \
    .replace('\f', '\\f') \
    .replace('\r', '\\r') \
    .replace('\v', '\\v') \
    .replace('\"', '\\\"')

output = '"' + output + '"'

if args.multiline:
    output = output.replace('\\n', '\\n" +\n"')

stdout.write(output)
